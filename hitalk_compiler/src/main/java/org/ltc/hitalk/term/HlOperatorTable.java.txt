package org.ltc.hitalk.term;

import com.thesett.aima.logic.fol.Term;
import com.thesett.common.parsing.SourceCodeException;
import com.thesett.common.util.StackQueue;
import org.ltc.hitalk.compiler.bktables.IOperatorTable;
import org.ltc.hitalk.term.HlOpSymbol.Fixity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static org.ltc.hitalk.term.HlOpSymbol.Fixity.*;
import static org.ltc.hitalk.term.HlOperatorTable.Symbol.Final;
import static org.ltc.hitalk.term.HlOperatorTable.Symbol.Op;

public class HlOperatorTable implements IOperatorTable {
    /**
     * Used for debugging purposes.
     */
    private final Logger logger = LoggerFactory.getLogger(getClass().getSimpleName());

    /**
     * Encodes the possible symbols that this parser accepts.
     */
    enum Symbol {
        /**
         * A term which is not a {@link CandidateOperator}. It may be a previously resolved {@link HlOpSymbol} though.
         */
        Term,

        /**
         * A symbol which is a {@link CandidateOperator} to be resovled onto an {@link HlOpSymbol}.
         */
        Op,

        /**
         * A final symbol to complete the sequence.
         */
        Final,
    }

    /**
     * Defines the action to shift to state 1.
     */
    private final HlOperatorTable.ShiftAction s1 = new HlOperatorTable.ShiftAction(1);

    /**
     * Defines the action to shift to state 2.
     */
    private final HlOperatorTable.ShiftAction s2 = new HlOperatorTable.ShiftAction(2);

    /**
     * Defines the action to shift to state 5.
     */
    private final HlOperatorTable.ShiftAction s5 = new HlOperatorTable.ShiftAction(5);

    /**
     * Defines the action to resolve using rule 1.
     */
    private final HlOperatorTable.ReduceAction r1 = new HlOperatorTable.ReduceAction(1);

    /**
     * Defines the action to resolve using rule 2.
     */
    private final HlOperatorTable.ReduceAction r2 = new HlOperatorTable.ReduceAction(2);

    /**
     * Defines the action to resolve using rule 3.
     */
    private final HlOperatorTable.ReduceAction r3 = new HlOperatorTable.ReduceAction(3);

    /**
     * Defines the action to resolve using rule 4.
     */
    private final HlOperatorTable.ReduceAction r4 = new HlOperatorTable.ReduceAction(4);

    /**
     * Defines an error message when the final symbol is encountered in the start state.
     */
    private final HlOperatorTable.ErrorAction e1 = new HlOperatorTable.ErrorAction("Term sequence cannot be empty.");

    /**
     * Defines an error message when nothing is specified to apply an operator to.
     */
    private final HlOperatorTable.ErrorAction e2 = new HlOperatorTable.ErrorAction("Something expected after operator.");

    /**
     * Defines an error message when two adjacement terms no seperated by an operator are encounterd.
     */
    private final HlOperatorTable.ErrorAction e3 = new HlOperatorTable.ErrorAction("Cannot have two adjacent non-operator terms.");

    /**
     * Holds the LR parser action table, that describes which action to perform when encountering a given symbol in a
     * given state. The first index to the two dimensional array is the state number, the second is the {@link HlOperatorTable.Symbol}s
     * ordinal value. Note that there are three operator/operator shift/reduce conflicts in this table.
     */
    private final HlOperatorTable.Action[][] actionTable =
            new HlOperatorTable.Action[][]
                    {
                            {s1, s2, e1},
                            {r1, r1, r1},
                            {s1, s2, e2},
                            {e3, s5, new HlOperatorTable.Accept()},
                            {r2, new HlOperatorTable.ResolveAction(s5, r2), r2},
                            {s1, new HlOperatorTable.ResolveAction(s2, r3), r3},
                            {r4, new HlOperatorTable.ResolveAction(s5, r4), r4}
                    };

    /**
     * Holds the LR parser goto table, that describes the state to transition to after resolving a rule.
     */
    private final Integer[] gotoTable = new Integer[]{3, null, 4, null, null, 6, null};

    /**
     * Holds the rules to apply when resolving.
     */
    private final HlOperatorTable.Action[] rules = {null, new HlOperatorTable.Rule1(), new HlOperatorTable.Rule2(), new HlOperatorTable.Rule3(), new HlOperatorTable.Rule4()};

    /**
     * Holds the parser state stack.
     */
    private final Queue <Integer> stack = new StackQueue <>();

    /**
     * Holds the parsers current state.
     */
    private int state;

    /**
     * Holds the parsers current position within the input sequence of terms.
     */
    private int position;

    /**
     * Holds the output stack onto which terms are placed pending their consumption by rule reductions.
     */
    private final Queue <Term> outputStack = new StackQueue <>();

    /**
     * Holds the current next term on the input sequence.
     */
    private Term nextTerm;

    /**
     * Holds the table of defined operators by name and fixity.
     */
    private final Map <String, EnumMap <Fixity, HlOpSymbol>> operators = new HashMap <>();

    /**
     * Parses a flat list of terms, which are literals, variables, functors, or operators into a tree in such a way that
     * the operators associativity and precendence is obeyed.
     *
     * @param terms A flat list of terms possibly containing operators, to be parsed.
     * @return The functor at the root of the sequence of terms parsed into an abstract syntax tree.
     * @throws SourceCodeException If the list of terms does not form a valid syntactical construction under the current
     *                             set of defined operators.
     */
    public Term parseOperators ( Term[] terms ) throws SourceCodeException {
        // Initialize the parsers state.
        stack.offer(0);
        state = 0;
        position = 0;
        nextTerm = null;

        // Consume the terms from left to right.
        for (position = 0; position <= terms.length; ) {
            HlOperatorTable.Symbol nextSymbol;

            // Decide what the next symbol to parse is; candidate op, term or final.
            if (position < terms.length) {
                nextTerm = terms[position];

                if (nextTerm instanceof CandidateOperator) {
                    nextSymbol = Op;
                } else {
                    nextSymbol = Symbol.Term;
                }
            } else {
                nextSymbol = Final;
            }

            // Look in the action table to find the action associated with the current symbol and state.
            HlOperatorTable.Action action = actionTable[state][nextSymbol.ordinal()];

            // Apply the action.
            action.apply();
        }

        return outputStack.poll();
    }

    /**
     * Sets the priority and associativity of a named operator in this table. This method may be used to remove
     * operators by some implementations, through a special setting of the priority value. A priority value of zero will
     * remove any existing operator matching the fixity of the one specified (that is pre, or post/infix). To be
     * accepted, the operator must have a priority between 0 and 1200 inclusive, and can only be a postfix operator when
     * an infix is not already defined with the same name, and similarly for infix operators when a postfix operator is
     * already defined.
     */
    public void setOperator ( int name, String textName, int priority, HlOpSymbol.Associativity associativity ) {
        {
            // Check that the name of the operator is valid.

            // Check that the priority of the operator is valid.
            if ((priority < 0) || (priority > 1200)) {
                throw new IllegalArgumentException("Operator priority must be between 0 and 1200 inclusive.");
            }

            HlOpSymbol opSymbol = new HlOpSymbol(name, textName, associativity, priority);

            // Consult the defined operators to see if there are any already defined that match the name of the
            // new definition, otherwise a map of operators by fixity needs to be created.
            EnumMap <Fixity, HlOpSymbol> operatorMap = operators.get(textName);

            // Check if the priority is non-zero in which case the operator is being added or redefined.
            if (priority > 0) {
                if (operatorMap == null) {
                    operatorMap = new EnumMap <>(Fixity.class);
                    operators.put(textName, operatorMap);
                }

                // Check if the operators fixity to see if further rules regarding simultaneous definition of post and
                // infix operators need to be applied.
                if (opSymbol.isPostfix()) {
                    // Postfix, so check if an infix definition already exists, which is not allowed.
                    if (operatorMap.containsKey(In)) {
                        throw new IllegalArgumentException(
                                "Cannot define a postfix operator when an infix one with the same name already exists.");
                    }
                } else if (opSymbol.isInfix()) {
                    // Infix, so check if a postfix definition already exists, which is not allowed.
                    if (operatorMap.containsKey(Post)) {
                        throw new IllegalArgumentException(
                                "Cannot define an infix operator when an postfix one with the same name already exists.");
                    }
                }

                // Add the operator to the table replacing any previous definition of the same fixity.
                operatorMap.put(opSymbol.getFixity(), opSymbol);
            } else {
                // The priority is zero, in which case the operator is to be removed.
                if ((operatorMap != null) && opSymbol.isPrefix()) {
                    // Remove it from the prefix table, if it exists there.
                    operatorMap.remove(Pre);
                } else if ((operatorMap != null) && (opSymbol.isPostfix() || opSymbol.isInfix())) {
                    // Remove it from the postfix/infix table, if it exists there.
                    operatorMap.remove(Post);
                    operatorMap.remove(In);
                }
            }
        }

        /**
         * Checks the operator table for all possible operators matching a given name.
         *
         * @param  name The interned name of the operator to find.
         *
         * @return An array of matching operators, or <tt>null</tt> if none can be found.
         */
        public EnumMap <Fixity, HlOpSymbol> getOperatorsMatchingNameByFixity (String name)
        {
            return operators.get(name);
        }

        /**
         * Prints the current state of this parser as a string, mainly for debugging purposes.
         *
         * @return The current state of this parser as a string.
         */
        public String toString ()
        {
            return "HlOperatorTable: [ state = " + state + ", nextTerm = " + nextTerm + " stack = " + stack +
                    " outputStack = " + outputStack + " ]";
        }

        /**
         * Checks if a candidate operator symbol can have one of the specified fixities, and resolve it to an oeprator with
         * that fixity if so. If it cannot be resolved an exception is raised.
         *
         * @param  candidate The candidate operator symbol to resolve.
         * @param  fixities  The possible fixities to resolve the symbol to.
         *
         * @return The candidate operator resolved to an actual operator.
         *
         * @throws SourceCodeException If the candidate operator cannot be resolved.
         */
        protected static HlOpSymbol checkAndResolveToFixity (CandidateOperator candidate, Fixity...fixities)
            throws SourceCodeException
        {
            HlOpSymbol result = null;

            for (Fixity fixity : fixities) {
                result = candidate.getPossibleOperators().get(fixity);

                if (result != null) {
                    break;
                }
            }

            if (result == null) {
                throw new SourceCodeException("Operator " + candidate + " must be one of " + Arrays.toString(fixities) +
                        ", but does not have the required form.", null, null, null, candidate.getSourceCodePosition());
            }

            return result;
        }

        /**
         * A base class for defining parsers actions and rule reductions from.
         */
        private abstract static class Action {
            /**
             * Applies a parser action; shift, reduce, resolve or accept.
             *
             * @throws SourceCodeException With an error location if the action cannot be performed because the input
             *                             sequence does not form a valid instance of the grammar.
             */
            public abstract void apply () throws SourceCodeException;
        }

        /**
         * Defines a shift action. Shift changes to a new state, places the new state on the stack, consumes one input
         * symbol and places the symbol on the output stack.
         */
        private class ShiftAction extends HlOperatorTable.Action {
            /**
             * Holds the state to shift to.
             */
            public int toState;

            /**
             * Creates a shift action to the specified state.
             *
             * @param toState The state to shift to.
             */
            private ShiftAction ( int toState ) {
                this.toState = toState;
            }

            /**
             * Performs a shift action. Changes to a new state, places the new state on the stack, consumes one input symbol
             * and places the symbol on the output stack.
             */
            public void apply () {
                state = toState;
                stack.offer(state);
                position++;
                outputStack.offer(nextTerm);
            }
        }

        /**
         * Defines a reduce action. Reduce consumes states from the state stack, and symbols from the output stack in number
         * equal to the number of symbols on the right hand side of the rule that is being reduced by. It then shifts to the
         * state given by the goto table from the state left on top of the state stack. In this implementation the
         * consumption of symbols and states from the stacks is delegated to a {@link HlOperatorTable.Action} implementation.
         */
        private class ReduceAction extends HlOperatorTable.Action {
            /**
             * Holds the rule number to reduce by.
             */
            public int ruleNum;

            /**
             * Creates a reduce action to reduce by the specified rule.
             *
             * @param rule The rule number to reduce by.
             */
            private ReduceAction ( int rule ) {
                this.ruleNum = rule;
            }

            /**
             * Performs a reduce by the specified rule number.
             *
             * @throws SourceCodeException With an error location if the action cannot be performed because the input
             *                             sequence does not form a valid instance of the grammar.
             */
            public void apply () throws SourceCodeException {
                HlOperatorTable.Action rule = rules[ruleNum];
                rule.apply();

                state = gotoTable[stack.peek()];
                stack.offer(state);
            }
        }

        /**
         * ResolveAction decides a shift-reduce conflict between a pair of {@link CandidateOperator}s. The resolution
         * procedure is as described in the class level comment for {@link HlOperatorTable}.
         */
        private class ResolveAction extends HlOperatorTable.Action {
            /**
             * The shift action to perform if a shift resolution is chosen.
             */
            HlOperatorTable.ShiftAction shift;

            /**
             * The reduce action to perform if a reduce resolution is chosen.
             */
            HlOperatorTable.ReduceAction reduce;

            /**
             * Creates a resolve action between the specified shift and reduce actions.
             *
             * @param shift  The shift action to perform if a shift resolution is chosen.
             * @param reduce The reduce action to perform if a reduce resolution is chosen.
             */
            private ResolveAction ( HlOperatorTable.ShiftAction shift, HlOperatorTable.ReduceAction reduce ) {
                this.shift = shift;
                this.reduce = reduce;
            }

            /**
             * Performs shift-reduce resolution between a pair of operators as describe in {@link HlOperatorTable}.
             *
             * @throws SourceCodeException With an error location if the action cannot be performed because the input
             *                             sequence does not form a valid instance of the grammar.
             */
            public void apply () throws SourceCodeException {
                // This cast should not fail, as resolve is only called when the next symbol is a candidate operator.
                CandidateOperator nextCandidate = (CandidateOperator) nextTerm;

                // Walk back down the output stack looking for the last symbol and checking out what other terms may
                // exist on the stack too. This evaluates the output stack, looking at the previously parsed sequence
                // of terms that led to this conflict as a sequence of the form 'alpha OpA beta OpB', where OpA is the
                // previously unresolved operator conflicting with the nextTerm, and alpha and beta are potentially
                // empty sequences of symbols. The following code works out what the previous operator is and whether
                // alpha and beta are empty. At the end of this lastCandidate cannot be null, as resolve is only called
                // when a previous candidate symbol has been encountered.
                boolean alpha = false;
                boolean beta = false;
                CandidateOperator lastCandidate = null;
                int pos = 0;

                for (Term nextTerm : outputStack) {
                    boolean isHlOperator = (nextTerm instanceof CandidateOperator);

                    if ((pos == 0) && !isHlOperator) {
                        beta = true;
                    } else if ((pos == 0) && isHlOperator) {
                        lastCandidate = (CandidateOperator) nextTerm;
                    } else if ((pos == 1) && beta) {
                        lastCandidate = (CandidateOperator) nextTerm;
                    } else if ((pos == 1) && !beta) {
                        alpha = true;

                        break;
                    } else if (pos == 2) {
                        alpha = true;

                        break;
                    }

                    pos++;
                }

                if (lastCandidate == null) {
                    throw new IllegalStateException("'lastCandidate' is null but this should not be the case as this resolve " +
                            "action is only called when a previous candidate symbol exists.");
                }

                // Based on the form of the symbol sequence preceding the next symbol, work out which combination
                // of operator fixities in uniquely possible, and resolve the candidate operators onto that combination.
                HlOpSymbol lastOp;
                HlOpSymbol nextOp;

                if (alpha && beta) {
                    lastOp = checkAndResolveToFixity(lastCandidate, In);
                    nextOp = checkAndResolveToFixity(nextCandidate, In, Post);
                } else if (!alpha && beta) {
                    lastOp = checkAndResolveToFixity(lastCandidate, Pre);
                    nextOp = checkAndResolveToFixity(nextCandidate, In, Post);
                } else if (alpha && !beta) {
                    lastOp = checkAndResolveToFixity(lastCandidate, In, Post);

                    if (lastOp.isPostfix()) {
                        nextOp = checkAndResolveToFixity(nextCandidate, In, Post);
                    } else {
                        nextOp = checkAndResolveToFixity(nextCandidate, Pre);
                    }
                } else {
                    lastOp = checkAndResolveToFixity(lastCandidate, Pre);
                    nextOp = checkAndResolveToFixity(nextCandidate, Pre);
                }

                // Compare the priority and associativities of the conflicting operators to decide whether to shift
                // or reduce.
                int comparison = lastOp.compareTo(nextOp);

                if (comparison < 0) {
                    reduce.apply();
                } else if (comparison > 0) {
                    shift.apply();
                } else {
                    if (nextOp.isLeftAssociative()) {
                        reduce.apply();
                    } else if (nextOp.isRightAssociative()) {
                        shift.apply();
                    } else {
                        throw new SourceCodeException("Ambiguous operator associativity. Expression requires brackets.",
                                null, null, null, nextOp.getSourceCodePosition());
                    }
                }
            }
        }

        /**
         * An error handling action to be used when an unknown transition in the parser table is attempted. This action
         * creates a source code exception with the location of the error in it.
         */
        private class ErrorAction extends HlOperatorTable.Action {
            /**
             * Holds a custom error description.
             */
            private final String errorMessage;

            /**
             * Creates an error action with the specified error message.
             *
             * @param errorMessage The error message.
             */
            private ErrorAction ( String errorMessage ) {
                this.errorMessage = errorMessage;
            }

            /**
             * Applies a parser error action that will generate an exception with the location of the current parse term in
             * it.
             *
             * @throws SourceCodeException With an error location for the current parse term.
             */
            public void apply () throws SourceCodeException {
                throw new SourceCodeException(errorMessage, null, null, null, nextTerm.getSourceCodePosition());
            }
        }

        /**
         * Performs an accept action. This advances over the last symbol in the input sequence so that the parser
         * terminates.
         */
        private class Accept extends HlOperatorTable.Action {
            /**
             * Accepts the input sequence as valid.
             */
            public void apply () {
                // Advance one beyond the final position to indicate acceptance of the sentence as a valid instance of
                // the grammar.
                position++;
            }
        }

        /**
         * Implements a reduction by rule 1 of the grammar. This consumes a single state from the state stack.
         */
        private class Rule1 extends HlOperatorTable.Action {
            /**
             * Defines the number of symbols on the right hand side of this rule.
             */
            private static final int NUM_SYMBOLS_RHS = 1;

            /**
             * Reduces by rule 1.
             */
            public void apply () {
                for (int i = 0; i < NUM_SYMBOLS_RHS; i++) {
                    stack.poll();
                }
            }
        }

        /**
         * Implements a reduction by rule 2 of the grammar. This consumes two states from the state stack, and expects the
         * top two symbols on the output stack to be a terminal follow by an operator candidate that resolves to a prefix
         * operator.
         */
        private class Rule2 extends HlOperatorTable.Action {
            /**
             * Defines the number of symbols on the right hand side of this rule.
             */
            private static final int NUM_SYMBOLS_RHS = 2;

            /**
             * Reduces by rule 2.
             *
             * @throws SourceCodeException With an error location if the action cannot be performed because the input
             *                             sequence does not form a valid instance of the grammar.
             */
            public void apply () throws SourceCodeException {
                // Consume from the state stack for the number of RHS symbols.
                for (int i = 0; i < NUM_SYMBOLS_RHS; i++) {
                    stack.poll();
                }

                // Attempt to consume a term and an operator in prefix order from the output stack.
                Term t = outputStack.poll();
                CandidateOperator candidate = (CandidateOperator) outputStack.poll();

                HlOpSymbol op = checkAndResolveToFixity(candidate, Pre);

                // Clone the operator symbol from the operator table before adding the unique source code position and
                // argument for this symbol instance.
                op.setSourceCodePosition(candidate.getSourceCodePosition());
                op.setArguments(new Term[]{t});

                // Place the fully parsed, promoted operator back onto the output stack.
                outputStack.offer(op);
            }
        }

        /**
         * Implements a reduction by rule 3 of the grammar. This consumes two states from the state stack, and expects the
         * top two symbols on the output stack to be an operator candidate that resolves to a postfix operator followed by a
         * terminal.
         */
        private class Rule3 extends HlOperatorTable.Action {
            /**
             * Defines the number of symbols on the right hand side of this rule.
             */
            private static final int NUM_SYMBOLS_RHS = 2;

            /**
             * Reduces by rule 3.
             *
             * @throws SourceCodeException With an error location if the action cannot be performed because the input
             *                             sequence does not form a valid instance of the grammar.
             */
            public void apply () throws SourceCodeException {
                // Consume from the state stack for the number of RHS symbols.
                for (int i = 0; i < NUM_SYMBOLS_RHS; i++) {
                    stack.poll();
                }

                // Attempt to consume an operator and a term in postfix order from the output stack.
                CandidateOperator candidate = (CandidateOperator) outputStack.poll();
                Term t = outputStack.poll();

                HlOpSymbol op = checkAndResolveToFixity(candidate, Post);

                // Clone the operator symbol from the operator table before adding the unique source code position and
                // argument for this symbol instance.
                op = op.copySymbol();
                op.setSourceCodePosition(candidate.getSourceCodePosition());
                op.setArguments(new Term[]{t});

                outputStack.offer(op);
            }
        }

        /**
         * Implements a reduction by rule 3 of the grammar. This consumes three states from the state stack, and expects the
         * top three symbols on the output stack to be a terminal followed by ann operator candidate that resolves to a
         * infix operator followed by a terminal.
         */
        private class Rule4 extends HlOperatorTable.Action {
            /**
             * Defines the number of symbols on the right hand side of this rule.
             */
            private static final int NUM_SYMBOLS_RHS = 3;

            /**
             * Reduces by rule 4.
             *
             * @throws SourceCodeException With an error location if the action cannot be performed because the input
             *                             sequence does not form a valid instance of the grammar.
             */
            public void apply () throws SourceCodeException {
                // Consume from the state stack for the number of RHS symbols.
                for (int i = 0; i < NUM_SYMBOLS_RHS; i++) {
                    stack.poll();
                }

                // Attempt to consume a term, ann operator and a term in infix order from the output stack.
                Term t1 = outputStack.poll();
                CandidateOperator candidate = (CandidateOperator) outputStack.poll();
                Term t2 = outputStack.poll();

                HlOpSymbol op = checkAndResolveToFixity(candidate, In);

                // Clone the operator symbol from the operator table before adding the unique source code position and
                // argument for this symbol instance.
                // Note that the order of the arguments is swapped here, because they come off the stack backwards.
                op = op.copySymbol();
                op.setSourceCodePosition(candidate.getSourceCodePosition());
                op.setArguments(new Term[]{t2, t1});

                outputStack.offer(op);
            }
        }
    }

    @Override
    public EnumMap <Fixity, HlOpSymbol> getOperatorsMatchingNameByFixity ( String name ) {
        return null;
    }

    public class ShiftAction {
    }
}
