package org.ltc.hitalk.term;

import com.thesett.aima.search.Operator;
import com.thesett.aima.search.Traversable;
import org.ltc.hitalk.compiler.IVafInterner;
import org.ltc.hitalk.core.utils.TermUtilities;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import static org.ltc.hitalk.term.ListTerm.Kind.LIST;

/**
 *
 */
public class ListTerm<T extends ITerm<T>> extends HtBaseTerm<T> {
  //  public final ListTerm<T> NIL = new ListTerm<>(emptyList());

    /**
     * @param arg
     */
    public ListTerm(T arg) {
        addHead(arg);
    }

    public ListTerm(Kind kind, int arity) {
        this.kind = kind;
        //this.heads.addAll(Arrays.asList(new ITerm[arity]));fixme
    }

    public Kind getKind() {
        return kind;
    }

    protected Kind kind;//fixme encode in name
    final List<T> heads = new ArrayList<>();

    /**
     * @param arity
     */
    public ListTerm(int arity) {
        this(LIST, arity);
    }

    /**
     * @param kind
     * @param terms
     */
    public ListTerm(Kind kind, ListTerm<T> terms) {
        this.kind = kind;
        heads.clear();
        heads.addAll(terms.getHeads());
    }

    /**
     * @param kind
     * @param headTail
     */
    public ListTerm(Kind kind, List<T> headTail) {
        this.kind = kind;
        heads.clear();
        heads.addAll(headTail);
    }

    /**
     * @param names
     * @return
     */
    public List<T> addHeads(int... names) {
        for (final int name : names) {
            addHead(name);
        }
        return heads;
    }

    /**
     * @param i
     * @return
     */
    public int addHead(int i) {
        final IntTerm t = new IntTerm(i);
        heads.add((T) t);
        return i;
    }

    /**
     * @param names
     * @return
     */
    public List<T> addHeads(T... names) {
        for (final T name : names) {
            addHead(name);
        }
        return heads;
    }

    /**
     * @param names
     * @return
     */
    public List<T> addHead(T... names) {
        Collections.addAll(heads, names);
        return heads;
    }

    /**
     * @param heads
     */
    public ListTerm(final List<T> heads) {
        int bound = this.getHeads().size();
        for (int i = 0; i < bound; i++) {
            this.heads.add(heads.get(i));
        }
        this.newTail(false);
    }

    /**
     * @param kind
     * @param tail
     * @param heads
     */
    public ListTerm(Kind kind, List<T> heads, T tail) {
        this.kind = kind;
        heads.add(tail);
        setHeads(heads);
    }

    /**
     * @param heads
     * @param tail
     */
    public ListTerm(List<T> heads, T tail) {
        this(LIST, heads, tail);
    }

    /**
     * args = name + heads + tail
     *
     * @return
     */
    public List<T> getHeads() {
        return heads;
    }

    /**
     * @return
     */
    public boolean isNil() {
        return size() == 0;
    }

    /**
     * @return
     */
    public int size() {
        return getHeads().size();
    }

    /**
     * @return
     */
    public T getTail() {
        return TermUtilities.getLast(heads);
    }

    /**
     * @param i
     * @return
     */
    public T getHead(int i) {
        return getHeads().get(i);
    }

    /**
     * @return
     */
    @Override
    public boolean isList() {
        return true;
    }

    /**
     * @param i
     * @param term
     */
    public void setHead(int i, T term) {
        if (isConjunction(term)) {
            getHeads().set(i, term);
        }
    }

    private boolean isConjunction(T term) {
//        return (term.isList() && ((ListTerm) term).getKind() == CLAUSE_BODY);
        return true;//tidi
    }

    /**
     * @return
     */
    @Override
    public boolean isHiLog() {
        return false;
    }

    /**
     * Returns the state obtained by applying the specified operation. If the operation is not valid then this may
     * return <tt>null</tt>. The effect of the operator on the child state does not have to be evaluated immediately. It
     * can be done when this method is called, or when the goal predicate is evaluated.
     *
     * @param op The operator to apply to the traversable state.
     * @return The new traversable state generated by applying the specified operator.
     */
    public Traversable<T> getChildStateForOperator(Operator<T> op) {
        return op.getOp();
    }

    /**
     * {@inheritDoc}
     *
     * @param reverse
     */
    public Iterator<Operator<T>> validOperators(boolean reverse) {
        return (Iterator<Operator<T>>) getOp();
    }

    /**
     * @return
     */
    public boolean isJavaObject() {
        return false;
    }

    /**
     * Gets the actual value of a term, which is either the term itself, or in the case of variables, the value that is
     * currently assigned to the variable.
     *
     * @return The term itself, or the assigned value for variables.
     */
    public ITerm<T> getValue() {
        return null;
    }

    /**
     * Frees all assigned variables in the term, leaving them unassigned.
     */
    @Override
    public void free() {

    }

    /**
     * @param interner      The interner use to provide symbol names.
     * @param printVarName  <tt>true</tt> if the names of bound variables should be printed, <tt>false</tt> if just the
     *                      binding without the variable name should be printed.
     * @param printBindings <tt>true</tt> if variable binding values should be printed, <tt>false</tt> if just the
     *                      variables name without any binding should be printed.
     * @return
     */
    @Override
    public String toString(IVafInterner interner, boolean printVarName, boolean printBindings) {
        final StringBuilder sb = new StringBuilder();
        switch (kind) {
            case NIL:
                sb.append("[]");
            case LIST:
                sb.append("[");
                final List<T> heads = getHeads();
                final int iMax = heads.size() - 1;
                for (int i = 0; i < heads.size(); i++) {
                    sb.append(heads.get(i).toString(interner, printVarName, printBindings));
                    if (i < iMax) {
                        sb.append(", ");
                    } else if (i == iMax) {
                        sb.append('|');
                    }

                    sb.append(getTail().toString(interner, printVarName, printBindings));
                    sb.append("]");
                }
            case BYPASS:
                break;
            case AND:
                break;
            case OR:
                break;
            case NOT:
                break;
            case IF:
                break;
            case TRUE:
                break;
            case GOAL:
                break;
            case HILOG_APPLY:
                break;
            case INLINE_GOAL:
                break;
            case OTHER:
                break;
        }
        return sb.toString();
    }

    /**
     * @param isOpen
     */
    public void newTail(boolean isOpen) {
        addHeads(isOpen ? (T) new HtVariable<>() : (T) new ListTerm<T>(0));
    }

    public void setHeads(List<T> heads) {
        this.heads.clear();
        this.heads.addAll(heads);
    }

    /**
     * @param name
     * @return
     */
    public ListTerm<T> addHead(T name) {
        heads.add(name);
        return this;
    }

    public void addTail(T tail) {//fixme
        newTail(tail.isVar());
    }

    /**
     *
     */
    public enum Kind{
        NIL, //"[]" "{}" "()" BY  INTERNED NAME

        LIST, //-1 [.......]
        BYPASS,//-2
        AND,//-3 blocked  term
        OR,
        NOT,
        IF,
        TRUE,
        GOAL(),
        HILOG_APPLY,
        INLINE_GOAL,
        OTHER(),
        CLAUSE_BODY(),
        ARGS,
        BLOCK;

        /**
         *
         */
        Kind() {
        }
    }
}
