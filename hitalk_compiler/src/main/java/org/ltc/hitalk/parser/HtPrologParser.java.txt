/*
 * Copyright The Sett Ltd, 2005 to 2014.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright The Sett Ltd, 2005 to 2014.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.ltc.hitalk.parser;

import com.thesett.aima.logic.fol.*;
import com.thesett.aima.logic.fol.OpSymbol.Associativity;
import com.thesett.aima.logic.fol.OpSymbol.Fixity;
import com.thesett.aima.logic.fol.isoprologparser.CandidateOpSymbol;
import com.thesett.aima.logic.fol.isoprologparser.DynamicOperatorParser;
import com.thesett.aima.logic.fol.isoprologparser.OperatorTable;
import com.thesett.common.parsing.SourceCodeException;
import com.thesett.common.parsing.SourceCodePosition;
import com.thesett.common.parsing.SourceCodePositionImpl;
import com.thesett.common.util.Source;
import com.thesett.common.util.TraceIndenter;
import org.ltc.hitalk.compiler.bktables.BookKeepingTables;
import org.ltc.hitalk.entities.HtEntityIdentifier;
import org.ltc.hitalk.parser.jp.segfault.prolog.parser.*;
import org.ltc.hitalk.parser.jp.segfault.prolog.parser.PlToken.TokenKind;
import org.ltc.hitalk.term.io.HiTalkStream;
import org.ltc.hitalk.wam.compiler.HtFunctorName;

import java.util.*;
import java.util.logging.Logger;

import static com.thesett.aima.logic.fol.OpSymbol.Associativity.*;
import static com.thesett.aima.logic.fol.TermUtils.flattenTerm;
import static java.util.Objects.requireNonNull;
import static org.ltc.hitalk.core.BuiltIns.IMPLIES;
import static org.ltc.hitalk.core.BuiltIns.SEMICOLON;
import static org.ltc.hitalk.parser.jp.segfault.prolog.parser.PlPrologParser.BEGIN_OF_FILE;
import static org.ltc.hitalk.parser.jp.segfault.prolog.parser.PlPrologParser.END_OF_FILE;

/**
 * HtPrologParser is a recursive descent parser for the language Prolog, that parses its input into first order logic
 * {@link Term}s or {@link HtClause}s. The s generated by this parser are Terms in first order logic,
 * <p>
 * but not necessarily sentences in Prolog. A sentence in Prolog consists of either a Horn clause, to be added to the
 * current knowledge base, or a query, which is a Horn clause with no head, for immediate resolution against the current
 * knowledge base. Sentences in Prolog are Horn clauses and may be parsed through the  method.
 * <p>
 * <p/>A deffered decision parser, {@link DynamicOperatorParser}, is used to parse sequences of terms possibly involving
 * operators. This cannot easily be achieved with a recursive descent parser. See {@link DynamicOperatorParser} for the
 * details.
 *
 * <pre><p/><table id="crc"><caption>CRC Card</caption>
 * <tr><th> Responsibilities
 * <tr><td> Create a parser for Prolog on a token source. <td> {@link Source}
 * <tr><td> Parse a sentence in first order logic with dynamic operators. <td> {@link DynamicOperatorParser}.
 * <tr><td> Parse a sequence of sentences followed by an end of file.
 * <tr><td> Intern all Prolog built in functors and operators. <td> {@link VariableAndFunctorInterner}.
 * <tr><th> Table all Prolog build in operators. <td> {@link OperatorTable}.
 * </table></pre>
 *
 * @author Rupert Smith
 */
public class HtPrologParser implements Parser <Term, PlToken>, HtPrologParserConstants {

//    public static final String BEGIN_OF_FILE = "begin_of_file";
//    public static final String END_OF_FILE = "end_of_file";

    final protected static int HILOG_COMPOUND = 38;//todo wtf??

    /**
     * Used for logging to the console.
     */
    protected final Logger console = Logger.getLogger("CONSOLE." + getClass().getSimpleName());

    /**
     * Lists the tokens expected to begin a term expression as a string.
     */
    private static final String BEGIN_TERM_TOKENS = Arrays.toString(new String[]{tokenImage[FUNCTOR.ordinal()],
            tokenImage[LBRACKET.ordinal()], tokenImage[VAR.ordinal()], tokenImage[INTEGER_LITERAL.ordinal()], tokenImage[FLOATING_POINT_LITERAL.ordinal()], tokenImage[STRING_LITERAL.ordinal()], tokenImage[ATOM.ordinal()], tokenImage[BOF], tokenImage[LBRACE.ordinal()],//LPAREN
    });
    private TermFactory1<Term> factory;
    private OperatorTable1 optable;

    protected HiTalkStream stream;
    private Source <PlToken> source;

//    public HtPrologParser () {
//        super();
//        bkt = new BookKeepingTables();// fixme multiple instances of BKT's
//    }

    protected Parser <Term, PlToken> parser;

    /**
     * @param input
     * @param interner
     * @param factory
     * @param optable
     */
    public HtPrologParser ( HiTalkStream input, VariableAndFunctorInterner interner, TermFactory1 <Term> factory, OperatorTable1 optable ) {
//        super(input, interner, factory, optable);

        this.stream = input;
        this.interner = interner;
        this.factory = factory;
        this.optable = optable;
    }


    /**
     * @return
     */
    public long getFileBeginOffset () {
        return getTokenSource().getFileBeginOffset();
    }

    /**
     * Establishes the token source to parse from.
     *
     * @param source The token source to parse from.
     */
    @Override
    public void setTokenSource ( Source <PlToken> source ) {
        //setTokenSource((HtTokenSource) source);
        this.source = source;
    }

    /**
     * Parses the next sentence from the current token source.
     *
     * @return The fully parsed syntax tree for the next sentence.
     */
    @Override
    public Sentence <Term> parse () throws SourceCodeException {
        Sentence <Term> result;
//        HtClause clause = clause();
        Term term = term();
        if (term == null) {
            result = null;
        } else {
            result = new SentenceImpl <>(term);
        }
        return result;
    }

    /**
     * Sets up a custom operator symbol on the parser.
     *
     * @param operatorName  The name of the operator to create.
     * @param priority      The priority of the operator, zero unsets it.
     * @param associativity The operators associativity.
     */
    @Override
    public void setOperator ( String operatorName, int priority, Associativity associativity ) {
        EnumMap <Fixity, OpSymbol> ops = operatorTable.getOperatorsMatchingNameByFixity(operatorName);
        if (ops == null || ops.isEmpty()) {
            int arity = calcArity(associativity);
            operatorTable.setOperator(interner.internFunctorName(operatorName, arity), operatorName, priority, associativity);
        }
    }

    private int calcArity ( Associativity associativity ) {
        int arity;
        switch (associativity) {
            case XF:
            case YF:
            case FX:
            case FY:
                arity = 1;
                break;
            case XFX:
            case XFY:
            case YFX:
                arity = 2;
                break;
            default:
                throw new IllegalStateException("Unexpected value: " + associativity);
        }

        return arity;
    }

    /**
     * Describes the possible system directives in interactive mode.
     */
    public enum Directive {
        Trace, Info, User, File
    }

    /**
     * Holds the variable scoping context for the current sentence.
     */
    protected Map <Integer, Variable> variableContext = new HashMap <>();
    // fixme map isn't needed
    // list<variable> will do
    /**
     * Holds the byte code machine to compile into, if using compiled mode.
     */
    protected VariableAndFunctorInterner interner;
//    private final TermFactory1 <Term> factory;
//    private final OperatorTable1 optable;
    /**
     * Holds the dynamic operator parser for parsing terms involving operators.
     */
    protected DynamicOperatorParser operatorParser = new DynamicOperatorParser();
    /**
     * Holds the table of operators.
     */
    protected OperatorTable operatorTable = operatorParser;

    /**
     * Holds the indenter to provide neatly indended execution traces.
     */
    protected TraceIndenter indenter = new TraceIndenter(true);
    /**
     *
     */
    protected final Deque <PlTokenSource> tokenSourceStack = new ArrayDeque <>();

    /**
     * Builds a prolog parser on a token source to be parsed.
     *
     * @param tokenSource The token source to be parsed.
     * @param interner    The interner for variable and functor names.
     */
    public HtPrologParser ( PlTokenSource tokenSource, VariableAndFunctorInterner interner, BookKeepingTables bkt ) {
        //Set this parser up to use the supplied interner.
        this.interner = interner;
//        this.bkt = bkt;

        // Clears the variable scoping context for the first sentence.
        variableContext.clear();

        //Intern all of the built in symbols and functors in the language.
        initializeBuiltIns();

        setTokenSource(tokenSource);
    }

    /**
     * @return
     */
    public PlTokenSource getTokenSource () {
        return tokenSourceStack.peek();
    }

    /**
     * @return
     */
    public PlTokenSource popTokenSource () {
        return tokenSourceStack.pop();
    }

    /**
     * @param tokenSource
     */
    public void setTokenSource ( PlTokenSource tokenSource ) {
        tokenSourceStack.push(tokenSource);
    }

    /**
     * Parses a single terms, or atom (a functor with arity zero), as a sentence in first order logic. The sentence will
     * be parsed in a fresh variable context, to ensure its variables are scoped to within the term only. The sentence
     * does not have to be terminated by a full stop. This method is not generally used by Prolog, but is provided as a
     * convenience to languages over terms, rather than clauses.
     *
     * @return A term parsed in a fresh variable context.
     * @throws SourceCodeException If the token sequence does not parse into a valid term sentence.
     */
    public Term termSentence () throws SourceCodeException {
        // Each new sentence provides a new scope in which to make variables unique.
        variableContext.clear();

        Term sentence = term();

        return sentence;

    }

    /**
     * Parses a single horn clause as a sentence in first order logic.
     * A sentence consists of a clause followed by a full stop.
     *
     * @return A horn clause sentence in first order logic.
     * @throws SourceCodeException If the token sequence does not parse into a valid sentence.
     */
    public Term sentence () throws SourceCodeException {
        Sentence <Term> sentence = parse();
        if (sentence == null) {
            return null;
        }

        consumeToken(TokenKind.DOT);

        return sentence.getT();
    }

    /**
     * Parses many consecutive sentences, until an <EOF> is reached. This method is intended to aid with consulting
     * files.
     *
     * @return A list of parsed clauses.
     * @throws SourceCodeException If the token sequence does not parse into a sequence of clauses terminted by <EOF>.
     */
    public List <HtClause> sentences () throws SourceCodeException {
        List <HtClause> results = new ArrayList <>();

        // Loop consuming clauses until end of file is encountered.
        while (true) {
            if (peekAndConsume(TokenKind.BOF) || peekAndConsume(TokenKind.EOF)) {
                break;
            } else {
                results.add(clause());
            }
        }

        return results;
    }

    /**
     * Parses a single sentence in first order logic. A sentence consists of a term followed by a full stop.
     *
     * @return A sentence in first order logic.
     * @throws SourceCodeException If the token sequence does not parse into a valid sentence.
     */
    public HtClause clause () throws SourceCodeException {
        // Each new sentence provides a new scope in which to make variables unique.
        variableContext.clear();

        Term term = term();
        HtClause clause = convert((Functor) term);
        requireNonNull(clause);

        return clause;
    }

    protected HtClause convert ( Functor clauseTerm ) throws SourceCodeException {
        // Check if the top level term is a query, an implication or neither and reduce the term into a clause
        // accordingly.
        HtEntityIdentifier identifier = null;
        FunctorName fname = null;
        Functor[] body = null;
        Functor head = null;
        String name = interner.getFunctorName(clauseTerm);
        if (Objects.equals(IMPLIES.getName(), name)) {
            body = createBody((Functor) clauseTerm.getArgument(0));
            if (clauseTerm.getArity() == 2) {
                head = (Functor) clauseTerm.getArgument(1);
//                fname = interner.getDeinternedFunctorName(head.getName());
            } else {
            }
            return new HtClause(identifier, head, body);
        }
//            if (Objects.equals(COLON_COLON.getName(), fname.getName())) {
//                    if (fname.getArity() == 2) {
//                        identifier = (HtEntityIdentifier) head.getArgument(0);
//                        head = (Functor) head.getArgument(1);
////                        BkLoadedEntities record = (BkLoadedEntities) bkt.selectOne(BkTableKind.LOADED_ENTITIES, new BkLoadedEntities(new HtEntityIdentifier(identifier, null)));
////                        HtEntityIdentifier entity = record.getEntity1();
//                        return new HtClause(identifier, head, body);
//                    } else {
//                        // ::/1
//                    }
//                } else if (COLON.getName().equals(fname.getName()) && fname.getArity() == 2) {
//                    return new HtClause(head,body);//todo
//                } else {
//                    return null;// put clauses in user
//                }
        // }
        //   }
        else {
            head = clauseTerm;
            return new HtClause(null, head, null);
        }
    }

    private Functor[] createBody ( Functor functor ) throws SourceCodeException {
        List <Functor> flattenedArgs = flattenTerm(functor.getArgument(functor.getArity() - 1), Functor.class, PrologAtoms.COMMA, interner);

        return flattenedArgs.toArray(new Functor[flattenedArgs.size()]);
    }

    /**
     * Parses multiple sequential terms, and if more than one is encountered then the flat list of terms encountered
     * must contain operators in order to be valid Prolog syntax. In that case the flat list of terms is passed to the
     * {@link DynamicOperatorParser#parseOperators(Term[])} method for 'deferred decision parsing' of dynamic operators.
     *
     * @return A single first order logic term.
     * @throws SourceCodeException If the sequence of tokens does not form a valid syntactical construction as a first
     *                             order logic term.
     */
    public Term term () throws SourceCodeException {
        List <Term> terms = terms(new ArrayList <>());

        Term[] flatTerms = terms.toArray(new Term[terms.size()]);

        if (flatTerms.length > 1) {
            return operatorParser.parseOperators(flatTerms);
        } else {
            Term result = flatTerms[0];

            // If a single candidate op functor has been parsed, promote it to a constant.
            if (result instanceof CandidateOpSymbol) {
                CandidateOpSymbol candidate = (CandidateOpSymbol) result;

                int nameId = interner.internFunctorName(candidate.getTextName(), 0);
                result = new Functor(nameId, null);
            }

            return result;
        }
    }

    /**
     * Recursively parses terms, which may be functors, atoms, variables, literals or operators, into a flat list in the
     * order in which they are encountered.
     *
     * @param terms A list of terms to accumulate in.
     * @return The list of terms encountered in order.
     * @throws SourceCodeException If the sequence of tokens does not form a valid syntactical construction as a list of
     *                             first order logic terms.
     */
    public List <Term> terms ( List <Term> terms ) throws SourceCodeException {
        Term term = null;
        PlToken nextToken = getTokenSource().peek();
        switch (nextToken.kind) {
            case BOF:
                if (getTokenSource().isBofGenerated()) {
                    throw new IllegalStateException("The term begin_of_file is reserved.");
                }
//                consumeToken(BOF);
                term = new Functor(interner.internFunctorName(BEGIN_OF_FILE, 0), null);
                break;
            case EOF:
//                consumeToken(EOF);
                term = new Functor(interner.internFunctorName(END_OF_FILE, 0), null);
                break;
            case FUNCTOR:
                term = functor();
                break;
            case LBRACKET:
                term = listFunctor(consumeToken(LBRACKET));//ConsType.DOT_PAIR_CONS);
                // Mark the term as bracketed to ensure that this is its final parsed form. In particular the
                // #arglist method will not break it up if it contains commas.
                term.setBracketed(true);
                consumeToken(RBRACKET);
                break;
            case LBRACE:
//                term = listFunctor(consumeToken(LBRACE), ConsType.BYPASS_CONS);
                // Mark the term as bracketed to ensure that this is its final parsed form. In particular the
                // #arglist method will not break it up if it contains commas.
                term.setBracketed(true);
                consumeToken(RBRACE);
                break;
            case VAR:
                term = variable();
                break;
            case INTEGER_LITERAL:
                term = intLiteral();
                break;
            case FLOATING_POINT_LITERAL:
                term = doubleLiteral();
                break;
            case STRING_LITERAL:
                term = stringLiteral();
                break;
            case ATOM:
                term = atom();
                break;
            case LPAREN:
                consumeToken(LPAREN);
                term = term();
                // Mark the term as bracketed to ensure that this is its final parsed form. In particular the
                // #arglist method will not break it up if it contains commas.
                term.setBracketed(true);
                consumeToken(RPAREN);
                break;
            default:
                throw new SourceCodeException("Expected one of " + BEGIN_TERM_TOKENS + " but got " + tokenImage[nextToken.kind.ordinal()] + ".", null, null, null,
                        new SourceCodePositionImpl(nextToken.beginLine, nextToken.beginColumn, nextToken.endLine, nextToken.endColumn));
        }

        terms.add(term);

        switch (getTokenSource().peek().kind) {
            case LPAREN:
            case LBRACKET:
            case LBRACE:
            case INTEGER_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case VAR:
            case FUNCTOR:
            case ATOM:
                terms(terms);
                break;
            default:
        }

        return terms;
    }

    /**
     * Parses a single atom in first order logic. If the operator has been set up which has the same name as the atom
     * then the atom may actually be a functor expressed as a prefix, postfix or infix operator. If this is the case the
     * value returned by this method will be a {@link CandidateOpSymbol}. Otherwise it will be a {@link Functor} of
     * arity zero.
     *
     * @return A {@link CandidateOpSymbol} or a {@link Functor} or arity zero.
     * @throws SourceCodeException If the token sequence does not parse as a valid atom.
     */
    public Term atom () throws SourceCodeException {
        PlToken name = consumeToken(ATOM);
        Term result;

        // Used to build the possible set of operators that this functor could be parsed as.
        EnumMap <Fixity, OpSymbol> possibleOperators = operatorTable.getOperatorsMatchingNameByFixity(name.image);

        // Check if the functor mapped onto any candidate operators and if not create a constant for it.
        if ((possibleOperators == null) || possibleOperators.isEmpty()) {
            int nameId = interner.internFunctorName(name.image, 0);
            result = new Functor(nameId, null);
        } else {
            // Set the possible associativities of the operator on the candidate.
            result = new CandidateOpSymbol(name.image, possibleOperators);
        }

        // Set the position that the name was parsed from.
        SourceCodePosition position = new SourceCodePositionImpl(name.beginLine, name.beginColumn, name.endLine, name.endColumn);
        result.setSourceCodePosition(position);

        return result;
    }

    /**
     * Parses a single functor in first order logic with its arguments.
     *
     * @return A single functor in first order logic with its arguments.
     * @throws SourceCodeException If the token sequence does not parse as a valid functor.
     */
    public Term functor () throws SourceCodeException {
        PlToken name = consumeToken(FUNCTOR);

        Term[] args = null;//arglist(ConsType.ARGS_CONS);
//        consumeToken(RPAREN);

        int nameId = interner.internFunctorName((args == null) ? name.image : name.image.substring(0, name.image.length() - 1),
                (args == null) ? 0 : args.length);

        Functor result = new Functor(nameId, args);

        SourceCodePosition position = new SourceCodePositionImpl(name.beginLine, name.beginColumn, name.endLine, name.endColumn);
        result.setSourceCodePosition(position);

        return result;
    }

    /**
     * Parses a list expressed as a sequence of functors in first order logic. The empty list consists of the atom 'nil'
     * and a non-empty list consists of the functor 'cons' with arguments the head of the list and the remainder of the
     * list.
     * <p>
     * <p/>A list can be empty '[]', contains a sequence of terms seperated by commas '[a,...]', contain a sequence of
     * terms seperated by commas consed onto another term '[a,...|T]'. In the case where a term is consed onto the end,
     * if the term is itself a list the whole will form a list with a cons nil terminator, otherwise the term will be
     * consed onto the end as the list terminal.
     *
     * @return A list expressed as a sequence of functors in first order.
     * @throws SourceCodeException If the token sequence does not parse as a valid list.
     */
    public Term listFunctor ( PlToken leftDelim/*, ConsType consType */ ) throws SourceCodeException {
        // Get the interned names of the nil and cons functors.
//        int nilId = interner.internFunctorName(new HtFunctorName("[]", 0,1));
//        int vbar = interner.internFunctorName(new HtFunctorName("|", 1, 2));
//        consType = ConsType.DOT_PAIR_CONS;
//        int cons = interner.internFunctorName(String.format("%s %s", /*consType.begin*/, consType.end), 1);
//        int nilId = interner.internFunctorName(consType.begin + consType.end, 0);
        // A list (CONS) always starts with a '['.
        // Check if the list contains any arguments and parse them if so.
        Term[] args = null;
        PlToken nextToken = getTokenSource().peek();
//        consType.getRightDelimByLeftDelim(leftDelim.kind);
//        PlToken rightDelim = leftDelim;
        PlToken rightDelim = null;
        switch (nextToken.kind) {
//            case LBRACKET:
//                term = listFunctor(consumeToken(LBRACKET),ConsType.DOT_PAIR_CONS);
            // Mark the term as bracketed to ensure that this is its final parsed form. In particular the
            // #arglist method will not break it up if it contains commas.
//                term.setBracketed(true);
//
//                break;
//            case LBRACE:
//                leftDelim = consumeToken(LBRACE);
//                term =liFDterms
            // Mark the teFDterms form. In particular the
            // #arglist meFDterms
//                term.setFDterms
//                consumeTFDterms
//                break;
//            case LPAREN:
//                leftDelim = consumeToken(RPAREN);
            case INTEGER_LITERAL:
            case FLOATING_POINT_LITERAL:
            case STRING_LITERAL:
            case VAR:
            case FUNCTOR:
            case ATOM:
                args = null;//arglist(ConsType.DOT_PAIR_CONS); //deeper is used the regular list syntax
                break;
            case RPAREN:
                rightDelim = consumeToken(RPAREN);
                break;
            case RBRACKET:
                rightDelim = consumeToken(RBRACKET);
                break;
            case RBRACE:
                rightDelim = consumeToken(RBRACE);
                break;
            default:
                throw new IllegalStateException("Unexpected value: " + nextToken.kind);
        }

        // Work out what the terminal element in the list is. It will be 'nil' unless an explicit cons '|' has
        // been used to specify a different terminal element. In the case where cons is used explciitly, the
        // list prior to the cons must not be empty.
        Term accumulator;
        if (getTokenSource().peek().kind == CONS) {
            if (args == null) {
//                throw new SourceCodeException("Was expecting one of " + BEGIN_TERM_TOKENS + " but got " + tokenImage[nextToken.kind.ordinal();] + ".", null, null, null, new SourceCodePositionImpl(nextToken.beginLine, nextToken.beginColumn, nextToken.endLine, nextToken.endColumn);
            }

            consumeToken(CONS);
            accumulator = term();
        } else {
//            accumulator = new Nil(null, null);
        }

        // A list is always terminated with a ']'.
//       PlToken leftDelim = consType.kind1;
//        rightDelim = consType.kind2;

        // Walk down all of the lists arguments joining them together with cons/2 functors.
        if (args != null) // 'args' will contain one or more elements if not null.
        {
            for (int i = args.length - 1; i >= 0; i--) {
//                Term previousAccumulator = //accumulator;
                //accumulator = new Functor(consId.ordinal(), new Term[] { args[i], previousAccumulator });
//                accumulator = new Cons(cons, new Term[]{args[i], previousAccumulator});
//                todo consider [|List]
            }
        } else {
//            accumulator = new Cons(cons, new Term[]{null, accumulator});
        }

        // Set the position that the list was parsed from, as being the region between the '[' and ']' brackets.
        SourceCodePosition position = new SourceCodePositionImpl(leftDelim.beginLine, leftDelim.beginColumn, rightDelim.endLine, rightDelim.endColumn);
//        accumulator.setSourceCodePosition(position);

        // The cast must succeed because arglist must return at least one argument, therefore the cons generating
        // loop must have been run at least once. If arglist is not called at all because an empty list was
        // encountered, then the accumulator will contain the 'nil' constant which is a functor of arity zero.
        return null;// accumulator;
    }

//    /**
//     *
//     */
//    enum ConsType {
//        DOT_PAIR_CONS(LBRACKET, RBRACKET, "[", "]"), ARGS_CONS(LPAREN, RPAREN, "(", ")"), BYPASS_CONS(LBRACE, RBRACE, "{", "}"),//term if no bypass e.g. dcg
//        ;
//        private int kind1;
//        private int kind2;
//
//        private String begin;
//        private String end;
//
//        ConsType ( int kind1, int kind2, String begin, String end ) {
//            this.kind1 = kind1;
//            this.kind2 = kind2;
//            this.begin = begin;
//            this.end = end;
//        }
//
//        /**
//         * @return
//         */
//        public int getKind1 () {
//            return kind1;
//        }
//
//        /**
//         * @return
//         */
//        public int getKind2 () {
//            return kind2;
//        }

//        public int getRightDelimByLeftDelim ( int kind ) {
//            if (getKind1() == kind) {
//                return getKind2();
//            }
//            return getKind1();
//        }
//    }

    /**
     * Parses a sequence of terms as a comma separated argument list. The ',' operator in prolog can be used as an
     * operator, when it behaves as a functor of arity 2, or it can be used to separate a sequence of terms that are
     * arguments to a functor or list. The sequence of functors must first be parsed as a term, using the operator
     * precedence of "," to form the term. This method takes such a term and flattens it back into a list of terms,
     * breaking it only on a sequence of commas. Terms that have been parsed as a bracketed expression will not be
     * broken up.
     * <p>
     * <p/>For example, 'a, b, c' is broken into the list { a, b, c}. The example, 'a, (b, c), d' is broken into the
     * list { a, (b, c), d} and so on.
     *
     * @return A sequence of terms parsed as a term, then flattened back into a list separated by commas.
     * @throws SourceCodeException If the token sequence is not a valid term.
     */
//    public Term[] arglist ( ConsType consType ) throws SourceCodeException {
//        Term term = term();
//        List <Term> result = TermUtils.flattenTerm(term, Term.class, ",", interner);
//
//        return result.toArray(new Term[result.size()]);
//    }
//
//    public Term listContent ( ConsType consType ) throws SourceCodeException {
//        Term t;
//        PlToken token = getTokenSource().peek();
//        consumeToken(token.kind);
//        Term[] head = arglist(ConsType.DOT_PAIR_CONS);
//        Term tail = null;
//
//        if (peekAndConsume(CONS)) {
//            tail = term();
//        } else {
//            token = getTokenSource().peek();
//            if (!peekAndConsume(consType.kind2)) {
//                throw new SourceCodeException("Expected \"" + token.image + ". got \"" + consType.end + "\"", null, "", "", null);
//            }
//        }
//    }

    /**
     * Parses a variable in first order logic. Variables are scoped within the current sentence being parsed, so if the
     * variable has been seen previously in the sentence it is returned rather than a new one being created.
     *
     * @return A variable.
     * @throws SourceCodeException If the next token in the sequence is not a variable.
     */
    public Term variable () throws SourceCodeException {
        PlToken name = consumeToken(VAR);

        // Intern the variables name.
        int nameId = interner.internVariableName(name.image);

        // Check if the variable already exists in this scope, or create a new one if it does not.
        // If the variable is the unidentified anonymous variable '_', a fresh one will always be created.
        Variable var = null;

        if (!"_".equals(name.image)) {
            var = variableContext.get(nameId);
        }

        if (var != null) {
            return var;
        } else {
            var = new Variable(nameId, null, name.image.equals("_"));
            variableContext.put(nameId, var);

            return var;
        }
    }

    /**
     * Parses an integer literal.
     *
     * @return An integer literal.
     * @throws SourceCodeException If the next token in the sequence is not an integer literal.
     */
    public Term intLiteral () throws SourceCodeException {
        PlToken valToken = consumeToken(INTEGER_LITERAL);

        NumericType result = new IntLiteral(Integer.parseInt(valToken.image));

        // Set the position that the literal was parsed from.
        SourceCodePosition position = new SourceCodePositionImpl(valToken.beginLine, valToken.beginColumn, valToken.endLine, valToken.endColumn);
        result.setSourceCodePosition(position);

        return result;
    }

    /**
     * Parses a real number literal.
     *
     * @return A real number literal.
     * @throws SourceCodeException If the next token in the sequence is not a real number literal.
     */
    public Term doubleLiteral () throws SourceCodeException {
        PlToken valToken = consumeToken(FLOATING_POINT_LITERAL);

        NumericType result = new DoubleLiteral(Double.parseDouble(valToken.image));

        // Set the position that the literal was parsed from.
        SourceCodePosition position = new SourceCodePositionImpl(valToken.beginLine, valToken.beginColumn, valToken.endLine, valToken.endColumn);
        result.setSourceCodePosition(position);

        return result;
    }

    /**
     * Parses a string literal.
     *
     * @return A string literal.
     * @throws SourceCodeException If the next token in the sequence is not a string literal.
     */
    public Term stringLiteral () throws SourceCodeException {
        PlToken valToken = consumeToken(STRING_LITERAL);

        String valWithQuotes = valToken.image;

        StringLiteral result = new StringLiteral(valWithQuotes.substring(1, valWithQuotes.length() - 1));

        // Set the position that the literal was parsed from.
        SourceCodePosition position = new SourceCodePositionImpl(valToken.beginLine, valToken.beginColumn, valToken.endLine, valToken.endColumn);
        result.setSourceCodePosition(position);

        return result;
    }

    /**
     * Peeks at the next token to see if it is the system trace directive, and consumes it if it is.
     *
     * @return <tt>true</tt> iff the next token is the trace directive.
     */
    public boolean peekAndConsumeTrace () {
        return peekAndConsume(TRACE) && peekAndConsume(PERIOD);
    }

    /**
     * Peeks at the next token to see if it is the system info directive, and consumes it if it is.
     *
     * @return <tt>true</tt> iff the next token is the info directive.
     */
    public boolean peekAndConsumeInfo () {
        return peekAndConsume(INFO) && peekAndConsume(PERIOD);
    }

    /**
     * Peeks at the next token to see if it is the system user directive, and consumes it if it is.
     *
     * @return <tt>true</tt> iff the next token is the user directive.
     */
    public boolean peekAndConsumeUser () {
        return peekAndConsume(USER) && peekAndConsume(PERIOD);
    }

    /**
     * Peeks at the next token to see if it is an {@link #ATOM} which is equal to ";" and if it is consumes it. If the
     * symbol is consumed then the return value indicates that this has happened. This is intended to be usefull for
     * interactive interpreters when querying the user to see if they want more solutions to be found.
     *
     * @return <tt>true</tt> if the next token is ";" and it is consumed.
     */
    public boolean peekAndConsumeMore () {
        PlToken nextToken = getTokenSource().peek();

        if ((nextToken.kind == ATOM) && Objects.equals(SEMICOLON.getName(), nextToken.image)) {
            try {
                consumeToken(ATOM);
            } catch (SourceCodeException e) {
                // If the peek ahead kind can not be consumed then something strange has gone wrong so report this
                // as a bug rather than try to recover from it.
                throw new IllegalStateException(e);
            }

            return true;
        } else {
            return false;
        }
    }

    /**
     * Peeks and consumes the next interactive system directive.
     *
     * @return The directive, or <tt>null</tt> if none is found.
     * @throws SourceCodeException If the source being parsed does not match the grammar.
     */
    public Directive peekAndConsumeDirective () throws SourceCodeException {
        if (peekAndConsumeTrace()) {
            return Directive.Trace;
        }

        if (peekAndConsumeInfo()) {
            return Directive.Info;
        }

        if (peekAndConsumeUser()) {
            return Directive.User;
        }

        return null;
    }

    /**
     * Interns an operators name as a functor of appropriate arity for the operators fixity, and sets the operator in
     * the operator table.
     *
     * @param operatorName  The name of the operator to create.
     * @param priority      The priority of the operator, zero unsets it.
     * @param associativity The operators associativity.
     */
    public void internOperator ( String operatorName, int priority, Associativity associativity ) {
        int arity;

        if ((associativity == XFY) | (associativity == YFX) | (associativity == XFX)) {
            arity = 2;
        } else {
            arity = 1;
        }

        int name = interner.internFunctorName(operatorName, arity);
        operatorTable.setOperator(name, operatorName, priority, associativity);
    }

    /**
     * Interns and inserts into the operator table all of the built in operators and functors in Prolog.
     */
    protected void initializeBuiltIns () {
        // Initializes the operator table with the standard ISO prolog built-in operators.
        internOperator(PrologAtoms.IMPLIES, 1200, XFX);
        internOperator(PrologAtoms.IMPLIES, 1200, FX);
        internOperator(PrologAtoms.DCG_IMPLIES, 1200, XFX);
        internOperator(PrologAtoms.QUERY, 1200, FX);

        internOperator(PrologAtoms.SEMICOLON, 1100, XFY);
        internOperator(PrologAtoms.IF, 1050, XFY);
        internOperator(PrologAtoms.IF_STAR, 1050, XFY);

        internOperator(PrologAtoms.COMMA, 1000, XFY);
        internOperator(PrologAtoms.NOT, 900, FY);

        internOperator(PrologAtoms.UNIFIES, 700, XFX);
        internOperator(PrologAtoms.NON_UNIFIES, 700, XFX);
        internOperator(PrologAtoms.IDENTICAL, 700, XFX);
        internOperator(PrologAtoms.NON_IDENTICAL, 700, XFX);
        internOperator(PrologAtoms.AT_LESS, 700, XFX);
        internOperator(PrologAtoms.AT_LESS_OR_EQUAL, 700, XFX);
        internOperator(PrologAtoms.AT_GREATER, 700, XFX);
        internOperator(PrologAtoms.AT_GREATER_OR_EQUAL, 700, XFX);
        internOperator(PrologAtoms.UNIV, 700, XFX);
        internOperator(PrologAtoms.IS, 700, XFX);
//        internOperator(PrologAtoms.C, 700, XFX);
        internOperator(PrologAtoms.EQ_BSLASH_EQ, 700, XFX);
        internOperator(PrologAtoms.LESS, 700, XFX);
        internOperator(PrologAtoms.LESS_OR_EQUAL, 700, XFX);
        internOperator(PrologAtoms.GREATER, 700, XFX);
        internOperator(PrologAtoms.GREATER_OR_EQUAL, 700, XFX);

//        internOperator(PrologAtoms."+", 500, YFX);
//        internOperator(PrologAtoms."-", 500, YFX);

        internOperator(PrologAtoms.BSLASH_SLASH, 500, YFX);
        internOperator(PrologAtoms.SLASH_BSLASH, 500, YFX);

        internOperator(PrologAtoms.SLASH, 400, YFX);
        internOperator(PrologAtoms.SLASH_SLASH, 400, YFX);
        internOperator(PrologAtoms.STAR, 400, YFX);
        internOperator(PrologAtoms.RSHIFT, 400, YFX);
        internOperator(PrologAtoms.LSHIFT, 400, YFX);
        internOperator(PrologAtoms.REM, 400, YFX);
        internOperator(PrologAtoms.MOD, 400, YFX);

        internOperator(PrologAtoms.MINUS, 200, FY);
        internOperator(PrologAtoms.UP, 200, YFX);
        internOperator(PrologAtoms.STAR_STAR, 200, YFX);
        internOperator(PrologAtoms.AS, 200, FY);
        //FIXME
        internOperator(PrologAtoms.VBAR, 1001, XFY);
        internOperator(PrologAtoms.VBAR, 1001, FY);

        // Intern all built in functors.
        interner.internFunctorName(PrologAtoms.ARGLIST_NIL, 0);
        interner.internFunctorName(new HtFunctorName(PrologAtoms.ARGLIST_CONS, 0, 2));

        interner.internFunctorName(PrologAtoms.NIL, 0);
        interner.internFunctorName(new HtFunctorName(PrologAtoms.CONS, 0, 2));

        interner.internFunctorName(PrologAtoms.TRUE, 0);
        interner.internFunctorName(PrologAtoms.FAIL, 0);
        interner.internFunctorName(PrologAtoms.FALSE, 0);
        interner.internFunctorName(PrologAtoms.CUT, 0);

        interner.internFunctorName(PrologAtoms.BYPASS_NIL, 0);
        interner.internFunctorName(new HtFunctorName(PrologAtoms.BYPASS_CONS, 0, 2));
    }

    /**
     * Consumes a token of the expected kind from the token sequence. If the next token in the sequence is not of the
     * expected kind an error will be raised.
     *
     * @param kind The kind of token to consume.
     * @return The consumed token of the expected kind.
     * @throws SourceCodeException If the next token in the sequence is not of the expected kind.
     */
    protected PlToken consumeToken ( TokenKind kind ) throws SourceCodeException {
        PlToken nextToken = getTokenSource().peek();

        if (nextToken.kind != kind) {
            throw new SourceCodeException("Expected " + tokenImage[kind.ordinal()] + " but got " + tokenImage[nextToken.kind.ordinal()] + ".", null, null, null, new SourceCodePositionImpl(nextToken.beginLine, nextToken.beginColumn, nextToken.endLine, nextToken.endColumn));
        } else {
            nextToken = getTokenSource().poll();

            return nextToken;
        }
    }

    /**
     * Peeks ahead for the given token entityKind, and if one is foudn with that entityKind, it is consumed.
     *
     * @param kind The token kind to look for.
     * @return <tt>true</tt> iff the token was found and consumed.
     */
    private boolean peekAndConsume ( TokenKind kind ) {
        PlToken nextToken = getTokenSource().peek();
        if (nextToken.kind == kind) {
            try {
                consumeToken(kind);
            } catch (SourceCodeException e) {
                // If the peek ahead kind can not be consumed then something strange has gone wrong so report this
                // as a bug rather than try to recover from it.
                throw new IllegalStateException(e);
            }
            return true;
        } else {
            return false;
        }
    }
}
